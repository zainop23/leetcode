// TC : O(3^(n^2)) or O(4^(n^2)). At each step there are 3 choices and total size of maze is n^2
// O(3^(n^2)) in practice, since after the first move one direction
//     (the cell we came from) is blocked, leaving ~3 valid choices.
//     Sometimes expressed as O(4^(n^2)) for simplicity (looser bound).
// SC: O(n^2) for visited matrix + recursion stack depth.

//direction array approach, better for cases with higher direction choices
#include <bits/stdc++.h> 
void search(string ans, vector<string> &result, vector < vector < int >> & arr,
     vector < vector < int >> &vis, int i, int j, int n, int di[], int dj[]){
    if(i==n-1 && j==n-1){
        result.push_back(ans);
        return;
    }
    string d ="DLRU";
    for(int idx=0; idx<4; idx++){
        int nexti = i+di[idx];
        int nextj = j+dj[idx];
        if(nexti < n && nextj <n && nexti >=0 && nextj >= 0 && !vis[nexti][nextj] && arr[nexti][nextj]==1){
            vis[i][j]=1;
            search(ans+d[idx],result,arr,vis,nexti, nextj,n,di,dj);
            vis[i][j]=0;
        }
    }
}

vector < string > searchMaze(vector < vector < int >> & arr, int n) {
    if(arr[0][0]==0) return {{}};
    vector<string> result;
    vector < vector < int >> vis(n,vector<int>(n,0));
    string ans="";
    int di[] = {1,0,0,-1};
    int dj[] = {0,-1,1,0};
    search(ans,result,arr,vis,0,0,n,di,dj);
    sort(result.begin(),result.end());
    return result;
}

// if statements approach

#include <bits/stdc++.h> 
void search(string ans, vector<string> &result, vector < vector < int >> & arr,
     vector < vector < int >> &vis, int i, int j, int n){
    if(i==n-1 && j==n-1){
        result.push_back(ans);
        return;
    }
    vis[i][j]=1;

    if(i+1<n && !vis[i+1][j] && arr[i+1][j]){
        ans.push_back('D');
        search(ans,result,arr,vis,i+1,j,n);
        ans.pop_back();
    }
    if(i-1>=0 && !vis[i-1][j] && arr[i-1][j]){
        ans.push_back('U');
        search(ans,result,arr,vis,i-1,j,n);
        ans.pop_back();
    }
     if(j+1<n && !vis[i][j+1] && arr[i][j+1]){
        ans.push_back('R');
        search(ans,result,arr,vis,i,j+1,n);
        ans.pop_back();
    }
     if(j-1>=0 && !vis[i][j-1] && arr[i][j-1]){
        ans.push_back('L');
        search(ans,result,arr,vis,i,j-1,n);
        ans.pop_back();
    }
    vis[i][j]=0;
}

vector < string > searchMaze(vector < vector < int >> & arr, int n) {
    if(arr[0][0]==0) return {{}};
    vector<string> result;
    vector < vector < int >> vis(n,vector<int>(n,0));
    string ans="";
    search(ans,result,arr,vis,0,0,n);
    sort(result.begin(),result.end());
    return result;
}
